#' Fit the gamma distribution to observed instream isotope.
#'
#' @description Find parameter of the gamma distribution by convoluting the fitted
#' sine-wave to precipitation with the gamma distribution. Here, parameters of the
#' gamma distribution is generated using uniform Latin Hypercube sampling. The
#' goodness-of-fit is evaluated by the mean (weighted or unweighted using streamflow
#' volume) square error between observed instream isotope and simulated instream isotope.
#'
#'
#' @param AP Amplitude of the sine wave \eqn{(c_P(t) = A_P \cdot sin(2 \pi t - \varphi_P) + k_P)} of
#' isotope concentration in precipitation. This can be a scalar or a vector
#' @param phiP Phase of the sine wave \eqn{(c_P(t) = A_P \cdot sin(2 \pi t - \varphi_P) + k_P)} of
#' isotope concentration in precipitation. This can be a scalar or a vector
#' @param kP The constant of the sine wave \eqn{(c_P(t) = A_P \cdot sin(2 \pi t - \varphi_P) + k_P)} of
#' isotope concentration in precipitation. This can be a scalar or a vector.
#' If AP, phiP, kP are vectors, they must have the same length
#' @param alphaRange The range of alpha (shape) parameter of the gamma distribution
#' @param betaRange The range of beta (scale) parameter of the gamma distribution
#' @param simulatedDate The date vector (yyyy-mm-dd format as.Date), indicating
#' the period of simulation
#' @param fittedData The fitted isotope concentration in streamflow for the simulatedDate.
#' This must have the same length as simulatedDate and contains no missing data.
#' The model will calculate the mean square error between the simulated and fitted data
#' This mean square error could be weighted if weight is given
#' @param weight The weight vectors (e.g., streamflow volume) at the simulatedDate.
#' Must be a vector of the same length with simulatedDate.
#' @param nIter Number of iterations. This function will generate a random nIter
#' parametersets (alpha, beta) within the user-defined range as above. These
#' parametersets will be combined with a random parameterset of AP[i], phiP[i],
#' and kP[i]. The mean square error (weighted if the weights are given) between
#' simulated and fittedData, the nBestIter iteration will be saved as output from
#' this function.
#' @param nBestIter Number of best parameters that will be save to output
#' @param nCores Number of cores for parallel simulation, e.g., if nIter = 10 and
#' nCores = 2, then there will be 2 parallel run on each cores with 5 iterations
#' @param nWarmupYears Number of warmup years.
#' @param setSeed An integer number used for set.seed() to have a reproducible
#' results.
#'
#' @return A list object containing table of simulated results, parameter
#' set generated by LHS, weighted mean square error (all are only for the
#' nBestIter best parameter sets).
#'
#' @details This function perform the following convolution equation to find the simulated
#' isotope in stream (please see Eq. 1 from Kirchner (2016)):
#'
#' \deqn{c_S(t) = \int_{0}^{\infty} h(\tau) \cdot c_P(t - \tau) d\tau }{}
#'
#' where \eqn{c_P(t)} in the following sine-wave form: \cr
#'
#'  \deqn{c_P(t) = A_P \cdot sin(2 \pi t - \varphi_P) + k_P}{}
#'
#' and the gamma distribution is:
#'
#' \deqn{h(\tau) =  \frac{\tau^{\alpha - 1}}{\beta^{\alpha} \Gamma (\alpha)} e^ {-\tau/\beta}}{}
#'
#' In this convolution, parameters of the sine-wave (which is the fitted sine-wave
#' to isotope in precipitation) are given as input to this convolution. Here, a number
#' of random parameter sets for the gamma are generated using uniform Latin Hypercube
#' Sampling and these sampled parameter sets are randomly combined with parameter sets
#' of the sine-wave.
#'
#' @importFrom foreach %dopar%
#' @importFrom utils stack
#'
#' @references Kirchner, J. W. (2016). Aggregation in environmental systems –
#' Part 1: Seasonal tracer cycles quantify young water fractions, but not mean
#' transit times, in spatially heterogeneous catchments. \emph{Hydrol. Earth Syst. Sci.},
#' 20, 279–297.
#'
#' @examples
#'
#' #Get isotope data in streamflow of the Alp catchment (from the example dataset)
#' isotopeS_Alp <- subset(isotopeData, catchment == "Alp" & variable == "streamflow")
#'
#'\dontrun{
#' simC <- fitGamma(AP = 1.909, phiP = 2.016, kP = -11.05995, alphaRange = c(0.01,5),
#'                      betaRange = c(0.01,10), simulatedDate = isotopeS_Alp$date,
#'                      fittedData = isotopeS_Alp$delta_18O,
#'                      weight = isotopeS_Alp$water_flux_mm, nIter = 8,
#'                      nBestIter = 3, nCores = 1,
#'                      nWarmupYears = 5)
#'}

#' @export

fitGamma <- function(AP = NULL, phiP = NULL, kP = NULL, alphaRange = NULL,
                     betaRange = NULL, simulatedDate = NULL, fittedData = NULL,
                     weight = NULL, nIter = 5000, nBestIter = 30, nCores = 1,
                     nWarmupYears = NULL, setSeed = NULL){

  # Set seed if provided
  if (!is.null(setSeed)) set.seed(setSeed)

  # Generate nIter number of parametersets within the range of [0,1]
  parameterSet <- lhs :: randomLHS(n = nIter, k = 2)

  # Add column name and convert to tibble
  colnames(parameterSet) <- c("alpha", "beta")
  parameterSet <- tibble::as_tibble(parameterSet)

  # Convert the generated parameter set to user-defined range
  parameterSet$alpha <- alphaRange[1] + parameterSet$alpha * (alphaRange[2] -alphaRange[1])
  parameterSet$beta <- betaRange[1] + parameterSet$beta * (betaRange[2] - betaRange[1])

  if (length(AP) != length(phiP) | length(AP) != length(kP)){
    stop("AP, phiP, and AP must be a scalar or vector of the same length")
  }

  # Set seed if provided
  if (!is.null(setSeed)) set.seed(setSeed)

  # Randomly mix AP, phiP, kP with parameterSet
  iloc <- sample.int(length(AP), nIter, replace = TRUE)
  parameterSet <- tibble::tibble(AP = AP[iloc], phiP = phiP[iloc], kP = kP[iloc],
                             alpha = parameterSet$alpha, beta = parameterSet$beta)

  # Make cluster
  cl <- parallel::makeCluster(nCores)
  doParallel::registerDoParallel(cl)

  # Get instream tracer concentrations by running on nCores
  simulated <- foreach::foreach(i = 1:nIter,
                        .combine = cbind,
                        .export=c("convolSineNL")) %dopar% {
    simC <- convolSineNL(AP = parameterSet$AP[i], phiP = parameterSet$phiP[i],
                         kP = parameterSet$kP[i], estAlpha = parameterSet$alpha[i],
                         estBeta = parameterSet$beta[i], simulatedDate = simulatedDate,
                         nWarmupYears = nWarmupYears, printAll = FALSE)
    simC$simulated
  }

  # Close cluster
  parallel::stopCluster(cl)

  # Calculate mean (weighted) square error
  weightedMSE <- rep(NA, nIter)
  for (i in 1:nIter){
    if(is.null(weight)){
      weightedMSE[i] <- mean((simulated[,i] - fittedData)^2)
    } else {
      weightedMSE[i] <- mean(weight * (simulated[,i] - fittedData)^2)
    }
  }

  # Ranking results by decreasing square error
  rankingDecreasing <- order(weightedMSE, decreasing = FALSE)

  # Sort simulated results by decreasing square error
  simulated <- simulated[,rankingDecreasing]
  colnames(simulated) <- paste0("simulation_", c(1:ncol(simulated)))

  date <- rep(simulatedDate, nBestIter)
  parameterSet <- parameterSet[rankingDecreasing,]

  # Create output object
  output <- list()

  # convert simulated to tibble
  output$simulated <- tibble::as_tibble(simulated[,1:nBestIter])

  # Stack and change column name
  output$simulated <- tibble::as_tibble(stack(output$simulated))
  colnames(output$simulated) <- c("simulated", "simulation")

  # Add date to simulated result
  output$simulated <- tibble::add_column(output$simulated, date = date, .before = 1)

  # Save parameter set and square error
  output$parameterSet <- parameterSet[1:nBestIter,]
  output$weightedMSE <- weightedMSE[rankingDecreasing][1:nBestIter]

  return(output)
}
