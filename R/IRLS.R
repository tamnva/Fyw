#' Iteratively reweighted least squares (IRLS) with optional point weights
#'
#' @param Y A numeric vector representing a response variable
#' @param X A numeric vector or array or matrix representing one or more
#' explanatory variables. If X is a numeric vector, X must have the same length
#' as Y. If X is an array (or data frame), the first dimension of X mas have
#' the same length as Y. Y and X must not be exactly collinear. This is not checked.
#' @param pweights An optional numeric vector of point weights (such as masses for
#'           mass-weighted regressions) the default weight vector gives all pweights
#'           the value of 1
#' @param iweights An optional numeric vector of initial values for the residual
#'           weights for the IRLS, the default weight vector gives all initial
#'           iweights's the value of 1
#' @param type An optional string constant indicating the weight function.
#'          the value of type could be "bisquare", "Welsch", or "Cauchy". Default
#'          weight function is Cauchy.
#'
#' @return Object of class "lm", generated by a call
#'         with the initial weighted updated by the selected weighting function
#'         fit$iweights
#' @source The IRLS used in this function was copied and modified from the code
#' provided in this link https://doi.org/10.5194/hess-22-3841-2018-supplement.
#
#' @references
#'
#' Kirchner, J. W. (2016). Aggregation in environmental systems – Part 1: Seasonal
#' tracer cycles quantify young water fractions, but not mean transit times,
#' in spatially heterogeneous catchments, Hydrol. Earth Syst. Sci., 20, 279–297,
#' https://doi.org/10.5194/hess-20-279-2016.
#'
#' von Freyberg, J., Allen, S. T., Seeger, S., Weiler, M., and Kirchner, J. W. (2018).
#' Sensitivity of young water fractions to hydro-climatic forcing and landscape
#' properties across 22 Swiss catchments, Hydrol. Earth Syst. Sci., 22,
#' 3841–3861, https://doi.org/10.5194/hess-22-3841-2018-supplement.
#'
#'
#' @examples
#' # Explanatory variables
#' X <- c(1:100) + runif(100)/10
#' # Response variable
#' Y <- X + runif(100)*50
#' # Point weights
#' pweights <- rep(1, length(X))
#' # Initial weights
#' iweights <- rep(1, length(X))
#' results <- IRLS(Y = Y, X = X, pweights = pweights,
#'                 iweights = iweights, type = "Cauchy")
#' summary(results)
#' results$iweights
#' @export

#-------------------------------------------------------------------------------
# THE BELOW HEADER WAS COPIED AS IT IS FROM THE ORIGINAL SOURCE CODE HEADER
#-------------------------------------------------------------------------------
# Iteratively reweighted least squares (IRLS) with optional point weights (in
# addition to residual weights that are adjusted to downweight data with unusually
# large residuals, as in conventional IRLS)
#
# Author: James Kirchner, ETH Zurich
# Public use allowed under GNU Public License v. 3
# (see http://www.gnu.org/licenses/gpl-3.0.en.html)
#-------------------------------------------------------------------------------
# Modified on 03.2023 by Tam V. Nguyen, UFZ Leipzig from the original source
# code in this link https://doi.org/10.5194/hess-22-3841-2018-supplement.
#-------------------------------------------------------------------------------

IRLS <- function(Y,
                 X,
                 pweights = rep(1,length(Y)),
                 iweights = rep(1,length(Y)),
                 type = "Cauchy") {

  # Bisquare weight function
  bisquare <- function(x, MAR) {
    if (MAR==0) w <- ifelse(x==0, 1, 0)
    else {
      w <- (1-(x/(6*MAR))^2)^2
      w[x>6*MAR] <- 0
    }
    return(w)
  }

  # Welsch weight function
  Welsch <- function(x, MAR) {
    if (MAR==0){
      w <- ifelse(x==0, 1, 0)
    } else {
        w <- exp(-(x/(4.4255*MAR))^2)
    }
    return(w)
  }

  # Cauchy weight function
  Cauchy <- function(x,MAR) {
    if (MAR==0){
      w <- ifelse(x==0, 1, 0)
    } else {
      w <- 1/(1+(x/(3.536*MAR))^2)
    }
    return(w)
  }


  if (type!="bisquare") {
    if (type!="Welsch") {
      if (type!="Cauchy") {
        stop("IRLS stopped: no valid weight type specified.  Valid functions are 'bisquare', 'Welsch', and 'Cauchy'")
      }
    }
  }


  if (length(Y) != length(pweights)) stop("IRLS stopped: supplied weight vector must be same length as Y")


  wwwt <- pweights*iweights

  # Convert to matrix if X is data frame
  if(is.data.frame(X)) X <- data.matrix(X)

  fit <- lm(Y ~ X, weights = wwwt, na.action = "na.omit") #initial least-squares fit

  wt_chg <- 999.0 #initialize weight change
  iter <- 0 #initialize the iteration counter

  ##############################################
  #Here's the iteration loop, which runs until the largest weight change for any point is less than 0.01, or iteration limit is exceeded
  ##############################################
  while ( (max(wt_chg,na.rm=TRUE) > 0.01) & !all(iter>10, summary(fit)$r.squared>0.999) ){
    if (iter>1000) stop("IRLS stopped: more than 1000 interations, sorry!")
    # This error can arise when Y is perfectly collinear with X for more than half the points,
    # and thus the MAR fluctuates near zero, with the weights never stabilizing.
    # That should normally be handled by the r-squared criterion for loop exiting as defined above.

    iter <- iter+1 #increment the iteration counter
    old_wt <- iweights #save the old vector of weights for comparison with the next one

    const <- fit$coefficients[1]   #this is the intercept
    slope <- fit$coefficients[2:length(fit$coefficients)] #this is the vector of regression coefficients

    #explicit calculation of residuals
    if (length(slope)==1) resid <- Y - const - X*slope
    else resid <- as.vector(Y - const - X %*% slope)
    #can't use residuals(fit) because missing values will mess up the assignment of weights in the steps that follow
    #note %*% is matrix multiplication in R

    abs_resid <- abs(resid)
    abs_resid_nonzero <- ifelse(Y==0, NA, abs_resid) #exclude residuals corresponding to exact zeroes from median, to avoid blowup when there are many repeated zeroes in any flow decile
    MAR <- median(abs_resid_nonzero, na.rm=TRUE)

    if (MAR==0.0) stop("IRLS stopped. Solution has collapsed: median absolute residual is zero!")

    if (type=="bisquare") iweights <- bisquare(abs_resid,MAR) #use bisquare weights
    else if (type=="Welsch") iweights <- Welsch(abs_resid,MAR) #use Welsch weights
    else if (type=="Cauchy") iweights <- Cauchy(abs_resid,MAR) #use Cauchy weights

    wwwt <- pweights*iweights

    #run multiple regression
    fit <- lm(Y ~ X, weights = wwwt, na.action = "na.omit")

    # calculate change in weights from previous iteration
    wt_chg <- abs(iweights - old_wt)

  } #end while

  # Add final weight to output
  fit$iweights <- iweights

  return(fit)

}
